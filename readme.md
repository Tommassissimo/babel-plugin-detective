# babel-detective [![Build Status](https://travis-ci.org/jamestalmage/babel-plugin-detective.svg?branch=master)](https://travis-ci.org/jamestalmage/babel-plugin-detective)

> A Babel 6 plugin that scans the AST for require calls and import statements


## Install

```
$ npm install --save babel-plugin-detective babel-core
```

## Usage

```js
import babel from 'babel-core';
const detective = require('babel-plugin-detective');
const myModule = require('my' + 'module');
const opts = {};


// data will be stored on `result.metadata.requires`
var result = babel.transformFileAsync('/path/to/file', {
  plugins:[['detective', opts]]
});

// convenience method to extract metadata
var metadata = detective.metadata(result);

console.log(metadata);
// {
//   strings: [
//     'babel-core', 
//     'babel-plugin-detective'
//   ],
//   expressions: [
//     {start: 110, end: 125} // loc of 'my' + 'module' expression
//   ]
// }
```


## API

### detective.metadata(previousParseResult)

During traversal, the plugin stores each discovered require/import on the Babel metadata object.
It can be extracted manually from `parseResult.metadata.requires`, or you can pass the parse result
to this conveniences method.


## Options


### opts.includeGenerated

Type: `boolean`
Default: `false`

If set to true, it will include `require` calls generated by previous plugins in the 
 tool chain. This will lead to some duplicate entries if ES2015 import statements are
 present in the file. This plugin already scans for ES2015 import statements, so you
 only need to use this if there is some other type of generated require statement you
 want to know about.
 
### opts.includeImport
 
 Type: `boolean`
 Default: `true`
 
 Include ES2015 imports in the metadata. All ES2015 imports will be of type `string`.

### opts.includeRequire

 Type: `boolean`
 Default: `true`
 
 Include CommonJS style `require(...)` statements in the metadata. CommonJS require
  statements will be pushed on to `metadata.strings` if the argument is a string literal.
  For dynamic expressions (`require(foo + bar)`), an object will be pushed on to `metadata.expressions`.
  They have `start` and `end` properties that can be used to extract the code directly from the original source.

### opts.word

Type: `string`
Default: `'require'`

The name of the require function. You most likely do not need to change this.

### opts.attachExpressionSource

Type: `boolean`
Default: `false`

Attach the actual expression code to each member of `metadata.expressions`.

```js
 expressions: [
   {start: 110, end: 125, code: "'my' + 'module'"}
 ]
```


## License

MIT Â© [James Talmage](http://github.com/jamestalmage)
